### 1.JVM定义
Java 虚拟机 （Java Virtual Machine）
### 2.JVM作用
加载 Java 程序，把字节码翻译成机器码再交由 CPU 执行的一个虚拟计算器。
### 3.JVM组成部分
- 类加载器
- 运行时数据区
- 执行引擎
- 本地库接口
### 4.JVM工作机制
- .java -> .class
- 类加载器 加载到内存里
- .class -> 机器码 CPU执行 并调用本地库接口
### 5.JVM内存布局
- 程序计数器：线程所执行的字节码的行号指示器；
  - 字节码解析器通过计数器的值来选取需要执行的字节码指令，分支、循 环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器来完成；
  - 如是 Native 方法，这个计数器就为空（undefined），该内存区域是唯一一个在 Java 虚拟机规范中没有规定 OutOfMemoryError 的区域；
- Java 虚拟机栈：描述Java方法执行的内存模型；
  - 每个方法在执行的同时都会创建一个线帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完成的过程，都对应着一个线帧在虚拟机栈中入栈到出栈的过程。
- 本地方法栈：本地方法栈是为虚拟机调用Native方法服务的；
  - 在 Java 虚拟机规范中对于本地方法栈没有特殊的要求，虚拟机可以自由的实现 它，因此在 Sun HotSpot 虚拟机直接把本地方法栈和虚拟机栈合二为一了。
- Java 堆：Java 堆唯一的目的就是存放对象实例；
  - Java 堆（Java Heap）是 JVM 中内存最大的一块，是被所有线程共享的，在虚拟机启动时候创建，Java 堆唯一的目的就是存放对象实例，随着 JIT 编译器的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化的技术将会导致一些微妙的变化，所有的对象都分配在堆上渐渐变得不那么绝对了。
  - 如果在堆中没有内存完成实例分配，并且堆不可以再扩展时，将会抛出OutOfMemoryError。 
  - Java 虚拟机规范规定，Java 堆可以处在物理上不连续的内存空间中，只要逻辑上连续即可，就像我们的磁盘空间一样。
  - 在实现上也可以是固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是可扩展的，通过 -Xmx 和 -Xms 控制。
- 方法区：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据；
  - 方法区（Methed Area）很多人把方法区称作“永久代”（Permanent Generation），本质上两者并不等价；
  - 只是 HotSpot 虚拟机垃圾回收器团队把 GC 分代收集扩展到了方法区，或者说是用来永久代来实现方法区而已，这样能省去专门为方法区编写内存管理的代码；
  - 但是在 JDK 8 也移除了“永久代”，使用 Native Memory 来实现方法区。当方法无法满足内存分配需求时会抛出 OutOfMemoryError 异常。


### 6.Java 程序是怎样运行的？
- 首先通过 Javac 编译器将 .java 转为 JVM 可加载的 .class 字节码文件。
- Javac 是由 Java 编写的程序，编译过程可以分为：
  - ① 词法解析，通过空格分割出单词、操作符、控制符等信息，形成 token 信息流，传递给语法解析器。
  - ② 语法解析，把 token 信息流按照 Java 语法规则组装成语法树。
  - ③ 语义分析，检查关键字使用是否合理、类型是否匹配、作用域是否正确等。
  - ④ 字节码生成，将前面各个步骤的信息转换为字节码。
- 字节码必须通过类加载过程加载到 JVM 后才可以执行，执行有三种模式，
  - 解释执行、
  - JIT 编译执行、
  - JIT 编译与解释器混合执行（主流 JVM 默认执行的方式）。
- 混合模式的优势在于解释器在启动时先解释执行，省去编译时间。
- 之后通过即时编译器 JIT 把字节码文件编译成本地机器码。
Java 程序最初都是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会认定其为"热点代码"，热点代码的检测主要有基于采样和基于计数器两种方式，为了提高热点代码的执行效率，虚拟机会把它们编译成本地机器码，尽可能对代码优化，在运行时完成这个任务的后端编译器被称为即时编译器。
还可以通过静态的提前编译器 AOT 直接把程序编译成与目标机器指令集相关的二进制代码。
### 7.类加载是什么？
Class 文件中描述的各类信息都需要加载到虚拟机后才能使用。JVM 把描述类的数据从 Class 文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程称为虚拟机的类加载机制。

与编译时需要连接的语言不同，Java 中类型的加载、连接和初始化都是在运行期间完成的，这增加了性能开销，但却提供了极高的扩展性，Java 动态扩展的语言特性就是依赖运行期动态加载和连接实现的。

一个类型从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期经历加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、解析和初始化三个部分称为连接。加载、验证、准备、初始化阶段的顺序是确定的，解析则不一定：可能在初始化之后再开始，这是为了支持 Java 的动态绑定。

### 8.类加载的过程是什么？
- 加载
  - 该阶段虚拟机需要完成三件事：① 通过一个类的全限定类名获取定义类的二进制字节流。② 将字节流所代表的静态存储结构转化为方法区的运行时数据区。③ 在内存中生成对应该类的 Class 实例，作为方法区这个类的数据访问入口。
- 验证 
  - 确保 Class 文件的字节流符合约束。如果虚拟机不检查输入的字节流，可能因为载入有错误或恶意企图的字节流而导致系统受攻击。验证主要包含四个阶段：文件格式验证、元数据验证、字节码验证、符号引用验证。
  - 验证重要但非必需，因为只有通过与否的区别，通过后对程序运行期没有任何影响。如果代码已被反复使用和验证过，在生产环境就可以考虑关闭大部分验证缩短类加载时间。
- 准备 
  - 为类静态变量分配内存并设置零值，该阶段进行的内存分配仅包括类变量，不包括实例变量。如果变量被 final 修饰，编译时 Javac 会为变量生成 ConstantValue 属性，准备阶段虚拟机会将变量值设为代码值。
- 解析 
  - 将常量池内的符号引用替换为直接引用。 
  - 符号引用以一组符号描述引用目标，可以是任何形式的字面量，只要使用时能无歧义地定位目标即可。与虚拟机内存布局无关，引用目标不一定已经加载到虚拟机内存。 
  - 直接引用是可以直接指向目标的指针、相对偏移量或能间接定位到目标的句柄。和虚拟机的内存布局相关，引用目标必须已在虚拟机的内存中存在。
- 初始化 
  - 直到该阶段 JVM 才开始执行类中编写的代码。准备阶段时变量赋过零值，初始化阶段会根据程序员的编码去初始化类变量和其他资源。初始化阶段就是执行类构造方法中的 <client> 方法，该方法是 Javac 自动生成的。
### 有哪些类加载器？
自 JDK1.2 起 Java 一直保持三层类加载器：
- 启动类加载器
  - 在 JVM 启动时创建，负责加载最核心的类，例如 Object、System 等。无法被程序直接引用，如果需要把加载委派给启动类加载器，直接使用 null 代替即可，因为启动类加载器通常由操作系统实现，并不存在于 JVM 体系。
- 平台类加载器
  - 从 JDK9 开始从扩展类加载器更换为平台类加载器，负载加载一些扩展的系统类，比如 XML、加密、压缩相关的功能类等。
- 应用类加载器 
  - 也称系统类加载器，负责加载用户类路径上的类库，可以直接在代码中使用。如果没有自定义类加载器，一般情况下应用类加载器就是默认的类加载器。自定义类加载器通过继承 ClassLoader 并重写 findClass 方法实现。
### 双亲委派模型是什么？
- 类加载器具有等级制度但非继承关系，以组合的方式复用父加载器的功能。双亲委派模型要求除了顶层的启动类加载器外，其余类加载器都应该有自己的父加载器。
- 一个类加载器收到了类加载请求，它不会自己去尝试加载，而将该请求委派给父加载器，每层的类加载器都是如此，因此所有加载请求最终都应该传送到启动类加载器，只有当父加载器反馈无法完成请求时，子加载器才会尝试。
- 类跟随它的加载器一起具备了有优先级的层次关系，确保某个类在各个类加载器环境中都是同一个，保证程序的稳定性。

### 如何判断两个类是否相等？
- 任意一个类都必须由类加载器和这个类本身共同确立其在虚拟机中的唯一性。
- 两个类只有由同一类加载器加载才有比较意义，否则即使两个类来源于同一个 Class 文件，被同一个 JVM 加载，只要类加载器不同，这两个类就必定不相